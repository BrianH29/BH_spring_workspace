package com.kh.spring.member.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import com.kh.spring.member.model.service.MemberService;
import com.kh.spring.member.model.service.MemberServiceImpl;
import com.kh.spring.member.model.vo.Member;

@Controller	// 어노테이션을 붙여줌으로써 해당 이 클래스 빈으로 등록됨(빈스케닝을 통해서)
public class MemberController {
	
	@Autowired
	private MemberService mService = new MemberServiceImpl(); 
	
	//* 파라미터(요청시 전달값)를 전송받는 방법  == 요청시 전달되는 값들 처리방법
	/*
	 * 1. HttpServletRequest로 총 전송받기 (기존의 jsp/servlet 떄의 방식)
	 * 	  해당 메소드 매겨변수로 HttpyServletRequest를 작성하면
	 *   내부적으로 메소드 실행시 스프링컨데이너가 자동으로 해당 객체를 인자로 주입해줌
	 */
	/*
	@RequestMapping("login.me") // 서블릿이라고 생각하면 됨 @RequestMapping 어노테이션을 붙여줌으로써 HandlerMapping
	public void loginMember(HttpServletRequest request) {
		
		String userId = request.getParameter("id"); 
		String userPwd = request.getParameter("pwd");
		
		System.out.println("ID:" + userId);
		System.out.println("pwd:" + userPwd);
		*/
	
		/*
		 * 2. @RequestParam 어노데이션 방식
		 * 	  스프링에서는 조금 더 간단하게 파라미터(요청시 전달값)를 받아올 수 있는 방법 제공
		 *   @RequestParam(value=="키") == request.getParameter("키")
		 */
	
		/*
		@RequestMapping("login.me")
		public void loginMember(@RequestParam(value="id", defaultValue="aaa")String userId, 
							    @RequestParam("pwd")String userPwd) {
			
			System.out.println("ID:" + userId);
			System.out.println("pwd:" + userPwd);
	}
	*/
		/*
		 * 3.@RequestParam 어노테이션 생략하는 방식
		 * 	 키값과 받아주는 메개변수 명이 같으면 
		 * 	위의 어노테이션을 생략해도 파라미터값을 가벼와서 변수에 저장 가능
		 *  "단, 매개변수를 name 값과 동일하게 해야 자동으로 값이 주입됨!! 
		 */
	
	/*
		@RequestMapping("login.me")
		public void loginMember(String userId, String userPwd) {
			System.out.println("ID:" + userId);
			System.out.println("pwd:" + userPwd);
			
			Member m = new Member();
			m.setUserId(userId);
			m.setUserPwd(userPwd);
		}
	*/
	
		/*
		 * 4. @ModelAttribute를 이용한 방식
		 * 	  요청시 전달되는 값들이 많을 경우 VO 객체에 바로 담아내고자 할때 쓰이는 방식 
		 *   --> 기본생성자와 setter를 이용한 주입 방식!! 
		 *   
		 *   커멘드 객체 방식이라고 함!
		 *   스프링컨테이너가 내부적으로 해당 객체 기본생성자로 생성한 후 setter메소드로
		 *   요청시 전달값들을 각 필드에 주입하는 방식!!
		 *   (주의: 반드시 name속성값이 내가 바로 담고자 하는 VO 객체의 필드명과 동일해야함!!)
		 */
		
	/*
		@RequestMapping("login.me")
		public void loginMember(@ModelAttribute Member m) {
			System.out.println("ID : " + m.getUserId());
			System.out.println("PWD :" + m.getUserPwd());
		}
	*/
	
		
		/*
		 * 5. 위의 @ModelAttribute 어노테이션 생략하고 바로 커멘드객체에 담기
		 */
		
		@RequestMapping("login.me")
		public void loginMember(Member m) {
			
			//맴버 컨트럴에서 이제 다 쓰일거 이기 때문에 필드 부로 뺴서 다 쓰게 하기 
			//MemberService mService = new MemberServiceImpl(); 
			
			//Member m = new MemberServiceImpl().loginMember(m); 
			
			/*
			 * 내가 직접 new 키워드를 통해서 객체 생성하게 되면
			 * 해당 객체와의 결합도가 강해짐!! 
			 * 
			 * 문제점 1. 생성하고 있는 클래스명이 바뀌었을 경우 => 객체 생성하는 구문에 빨간줄 => 코드를 수정해야만 함!
			 * 문제점 2. 매 요청때마다 생성된 객체의 주소값 달라짐 => 즉, 계속이 새로 객체 생성
			 * 		   => 10000건 요청이 있다면 10000개의 객체가 생성되고 사라지게 됨(new 라는 키워드로 발생하는 문제점)
			 * 
			 * 결합도를 낮추지 위해 의존성 주입(DI dependency injection)을 이용해보자! 
			 */
			
			System.out.println(mService);
		}
}
